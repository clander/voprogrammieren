# Zentrale Prozesse und Konzepte der Programmierung im Unterricht

## Warum programmieren wir in DGB?

TODO: ***

- weil es im Lehrplan steht ... Lehrplanauszüge zusammensuchen
  - ...
- weil der Lehrplan in den didaktischen Grundsätzen folgendes festhält:
  - ...
- Computational Thinking trainieren - NICHT Programmierer ausbilden
- Es geht darum eine Intuition davon zu vermitteln, wie die Wirkprinzipien aussehen
- Es geht darum, Türöffner zu sein -> sehen, was ist Programmieren, interessiert mich das, muss ich mich davor fürchten. (Insb. Mädchen), gefällt mir das, möchte ich das später machen …
- Bussmann-Heymann erfüllen (WICHTIG, insb. Wegen KI!)
- ... 

## Modellbildung
Im Zentrum des Unterrichts steht ein informatischer Modellbildungsprozess zur Lösung authentischer Problemsituationen. 

> Ein Modell ist eine abstrahierte Beschreibung eines realen oder geplanten Systems, das die für eine bestimmte Zielsetzung wesentlichen Eingenschaften des Systems erhält. Modellbildung ist die Beschreibung eines solchen Systems, z. B. mittels:
>
> * Systembeschreibungen
> * Verarbeitungsvorschriften
> * Datenstrukturen
>
> Modellierungstechniken:
>
> * Datenmodellierung
> * Ablaufmodellierung
> * Zustandsorientierte Modellierung
> * Funktionale Modellierung
> * Objektorientierte Modellierung
>
> (nach Hubwieser, Didaktik der Informatik)

Wir lösen ein (authentisches) Problem im Rahmen des informatischen Modellbildungsprozesses also, indem wir geistige und praktische Techniken der Informatik zur Anwendung bringen. Wir lernen dabei zentrale informatische Konzepte und Prozesse kennen und wir nutzen charakteristische Werkzeuge der Informatik, um Lösungen für Probleme zu realisieren. Dadurch entwickeln wir ein Verständnis über den Aufbau und die Wirkungsweise von Informatiksystemen. 

### Allgemeinbildung
Das wiederum ermöglicht uns im Sinne der Allgemeindlung ...

* ein korrektes Weltbild aufzubauen (indem etwa die Informatik und ihre Ideen, ihre Anwendungsgebiete, ihre gesamtheitlichen Auswirkungen auf unsere Lebenswelt überhaupt erst als solche realisiert werden können),
* Chancen, Grenzen und Risiken der Nutzung von Informationssystemen zu erkennen, 
* in einer mit Informatik durchsetzten Welt (auch zum eigenen Vorteil) zu partizipieren und sich etablieren,
* selbstbewusst, vernünftig, verantwortungsvoll und reflektiert mit den informatischen Technologien umzugehen.

Die Konzepte, Prozesse und Werkzeuge, die wir für die Lösungsfindung nutzen können, sind in der Informatik vielfältig. Zur Vermittlung zentraler geistiger sowie praktischer Techniken der Informatik eignen sich (nicht nur, aber insbesondere auch) Programmiersprachen und ihre Anwendung im Rahmen von authentischen Problemlösungsprozessen.

Dabei geht es nicht nur um Coding im engeren Sinne. Vielmehr steht der gesamte Modellbildungsprozess im Vordergrund, bei dem Coding nur einen Teilaspekt darstellt.

Es geht im allgemeinbildenden Informatik- bzw. DGB-Unterricht weiters nicht darum, Programmierer auszubilden, sondern um den Erkenntnisgewinn bezüglich der zentralen informatischen Konzepte und Prozesse im Zuge der Beschäftigung mit der Programmierung. 

### KI
Dieser Erkenntnisgewinn bezüglich echter informatischer Konzepte ist insbesondere vor dem Hintergrund der aktuellen Entwicklungen im Bereich der KI von ganz besonderer Bedeutung.

   * Wir selbst (nicht die KI, auch wenn wir diese für unsere Lösungen nutzen) tragen die Verantwortung für unser Tun und - wenn wir Informatiksysteme produzieren und nutzen - auch für andere.
   * Wir selbst müssen in der Lage sein, KI-Outputs zu kontrollieren. Nur wir selbst als Menschen können bezogen auf unseren lebensweltlichen Kontext und damit eingebettet in eine gesellschaftliche, politische, ökonomische und ökologische Realität über Korrektheit / Plausibilität / Angemessenheit / Ethik / Vernunft oder Moral entscheiden. 
   * Wir dürfen uns der Technologie nicht ausliefern. Wir müssen die Oberhand behalten.
   * Kreativität, Kritisches Denken, Teamwork, Kommunikation, unsere Erfahrungen als Menschen, die in der Realität leben, eingebettet in einen sozialen Kontext sind menschliche Stärken, die die KI so nicht leisten kann.
   * KI liefert bereits imposante Ergebnisse. Die komplexen und immer wieder neuen Herausforderungen unserer Zeit erfordern in Zukunft jedoch noch viel stärker als bisher menschliche Analyse- und Problemlösekompetenz.
   * KIs können als Assistenten bereits jetzt sehr gute Dienste leisten und die Produktivität von Domänen-Experten enorm steigern. Sie benötigten aber detaillierte menschliche Anleitung und Kontrolle, d. h. viel Kontext, Anleitung zur Lösung von kleineren Teilproblemen, Anfragen für Korrekturen und Anpassungen usw.

## Zentrale Konzepte
Im Rahmen der Nutzung von Programmiersprachen zur Lösung von Problemen gibt es verschiedene „Werkzeugkästen“ - auch Paradigmen genannt, die wiederum unterschiedliche Modellierungstechniken betreffen. 

Ein etablierter Werkzeugkasten ist der imperativ-prozedurale. Er enthält viele wichtige informatische Konzepte, von denen einige sogar als **Fundamentale Ideen der Informatik** (siehe unten) gesehen werden, darunter (Auszug):

* [Programm / Quellcode / Anweisungen](https://www.inf-schule.de/imperative-programmierung/python/konzepte/programme/konzept_programme)
  * Kompilieren und interpretieren
  * [Syntaxfehler](https://www.inf-schule.de/imperative-programmierung/python/konzepte/fehler/exkurs_syntaxfehler)
  * [Laufzeitfehler](https://www.inf-schule.de/imperative-programmierung/python/konzepte/fehler/exkurs_laufzeitfehler)
  * [Logische Fehler](https://www.inf-schule.de/imperative-programmierung/python/konzepte/fehler/exkurs_logischefehler)
* [Eingabe - Verarbeitung - Ausgabe (EVA)](https://www.inf-schule.de/imperative-programmierung/python/konzepte/programme/konzept_eva) in [Python](https://www.inf-schule.de/imperative-programmierung/python/konzepte/programme/exkurs_eingabeausgabe)
* [Bedingungen](https://www.inf-schule.de/imperative-programmierung/python/konzepte/bedingungen/konzept_bedingungen)
* [Logische Verknüpfungen](https://www.inf-schule.de/imperative-programmierung/python/konzepte/bedingungen/konzept_logischeverknuepfungen)
* [Variablen](https://www.inf-schule.de/imperative-programmierung/python/konzepte/variablen/konzept_variable) / Sichtbarkeit / Gültigkeit
* Werte (Literale)
* [Zuweisung (Assignment)](https://www.inf-schule.de/imperative-programmierung/python/konzepte/variablen/konzept_zuweisung)
* [Datentypen](https://www.inf-schule.de/imperative-programmierung/python/konzepte/datentypen/konzept_datentyp)
  * [Zahlen in Python](https://www.inf-schule.de/imperative-programmierung/python/konzepte/datentypen/exkurs_zahlen)
  * [Zeichenketten](https://www.inf-schule.de/imperative-programmierung/python/konzepte/zeichenketten/konzept_zeichenkette) in [Python](https://www.inf-schule.de/imperative-programmierung/python/konzepte/datentypen/exkurs_zeichenketten)
  * [Wahrheitswerte in Python](https://www.inf-schule.de/imperative-programmierung/python/konzepte/datentypen/exkurs_wahrheitswerte)
  * [Typumwandlung in Python](https://www.inf-schule.de/imperative-programmierung/python/konzepte/datentypen/exkurs_typumwandlungen)
* Listen und andere Datenstrukturen in Python:
  - Listen: https://www.inf-schule.de/imperative-programmierung/python/konzepte/listen
  - Listen: https://docs.python.org/3/tutorial/introduction.html#lists (Lists)
  - Sequence Types Lists, Tuples, Range: https://docs.python.org/3/library/stdtypes.html#typesseq
  - Sequence Type String: https://docs.python.org/3/library/stdtypes.html#textseq
  - Sets, Dictionaries: https://docs.python.org/3/tutorial/datastructures.html
* [Konstrollstrukturen](https://www.inf-schule.de/imperative-programmierung/python/konzepte/ablaufmodellierung/konzept_kontrollstrukturen):
  * Sequenzen von Anweisungen
  * [Fallunterscheidung (bedingte Verzweigungen)](https://www.inf-schule.de/imperative-programmierung/python/konzepte/entscheidungen/konzept_fallunterscheidungen)
  * [Wiederholung (Schleifen)](https://www.inf-schule.de/imperative-programmierung/python/konzepte/wiederholungen/konzept_wiederholungen)
  * [Ausnahmebehandlung](https://www.w3schools.com/python/python_try_except.asp)
* [Funktionen](https://www.inf-schule.de/imperative-programmierung/python/konzepte/funktion/konzept_funktion) als Modularisierungstechnik
* Ereignisse (Events) und Ereignisbehandlung (Callbacks)

Online-Ressourcen zu den Python-Konzepten:
  - [Inf-Schule.de](https://www.inf-schule.de/imperative-programmierung/python/)
  - [Programmierkonzepte](https://programmierkonzepte.ch)
  - [PythonGeeks](https://pythongeeks.org/learn-python-tutorial/)
  - [W3Schools](https://www.w3schools.com/python/)

## Zentrale Prozesse
Auch methodisch liegt der Fokus im Unterricht auf Problemlösen durch Modellbildung und Simulation. Die iterative Vorgehensweise ist an den Softwareentwicklungprozess angelehnt:

```mermaid
flowchart TD
    A[/Authentische Problemstellung/] 
    --> |Perzeption|B[Problem verstehen] 
    --> C[Problemanalyse] 
    --> |Abstraktion, Generalisierung, Dekomposition, Mustererkennung|D[/Lösungsansatz/] 
    --> E[Algorithmisierung] 
    --> |Modellierungstechnnik, algorithmische Grundbausteine, Datenstrukturen| F[/Systembeschreibung und Algorithmus, textuell / grafisch/] 
    --> G[Implementieren / Codieren] 
    --> H[/Programm/]
    --> I[Programm kompilieren] 
    --> J{Syntax korrekt?}
    --> |Nein| G
    J -->|Ja| K[/kompiliertes Programm/] 
    K --> L[Programm ausführen]
    L --> Q{Laufzeitfehler?}-->|Ja|M
    Q-->|Nein|N{Logische Fehler?} 
    -->|Nein| O[/Fertige Lösung/]
    N --> |Ja| M[Debugging]-->|Code anpassen|G
    M -->|Lösungsansatz anpassen|C
    M --> |Algorithmus anpassen|E
```

Die im Diagramm dargestellte Vorgehensweise vermischt den traditionellen Softwareentwicklungsprozess mit den zentralen Aspekten des Computational Thinkings:

1. Problemanalyse, etwa durch:
   * Problemspezifikation
   * Abstraktion
   * Generalisierung
   * Mustererkennung
   * Lösungsansätze
2. Algorithmisierung, etwa durch:
   * (grafische) Modellierungstechniken (z.B. Ablaufmodellierung, Zustandsmodellierung, funktionale Modellierung, objektorientierte Modellierung etc.)
   * Algorithmische Grundbausteine
   * Datenstrukturen
3. Implementierung und Test, etwa mit:
   * IDE
   * Programmiersprache
   * Laufzeitumgebungen und Compiler

**Hinweise zu Computational Thinking**
>Computational thinking (CT) refers to the thought processes involved in formulating problems so their solutions can be represented as computational steps and algorithms. In education, CT is a set of problem-solving methods that involve expressing problems and their solutions in ways that a computer could also execute. It involves automation of processes, but also using computing to explore, analyze, and understand processes (natural and artificial). (Wikipedia)

> Referenzen zum Thema Computational Thinking:
> * https://digitalpromise.org/initiative/computational-thinking/computational-thinking-for-next-generation-science/what-is-computational-thinking/
> * https://towardsdatascience.com/computational-thinking-defined-7806ffc70f5e
> * http://www.icompute-uk.com/news/computational-thinking-2/

**Hinweise zur Initiative "Denken lernen, Probleme lösen"**

Die Initiative [Denken lernen, Probleme lösen](https://dlpl.at) des BMBF greift [zentrale Ideen des informatischen Denkens](https://dlpl.at/informationen-fuer-die-lehrperson/methoden-des-informatischen-denkens-2) auf und unterstüzt die Umsetzung im Unterricht mit Aufgaben, in analoger Form mit Papier und Schere, haptisch mit einem Koffer mit Materialien oder auch digital in Form von Online-Angeboten.

### Problemanalyse
Das Problem wird analysiert und möglichst präzise formuliert. Dazu können z. B. Techniken des Computational Thinkings wie Abstraktion, Dekomposition oder Mustererkennung angewendet. Außerdem wird genau spezifiziert, wann das Problem als gelöst angesehen wird (Kriterien).

* Lösungsspezifikation: 
  * Wir definieren möglichst genaue "Abnahmekriterien" für eine Lösung.
* Abstraktion: 
  * Im Bereich Modellbildung: Wir fokussieren auf die für die Lösung absolut notwendigen Lösungselemente und lassen alles andere weg.
  * In Bezug zur Dekomposition: Wir verwenden vorgefertigte Teillösungen im Kontext größerer Lösungen (als Black-Box) weiter, ohne uns über die Implementierungsdetails Gedanken zu machen.
* Generalisierung: 
  * Wir versuchen eine Lösung zu finden, die nicht nur Spezialfälle von Problemen, sondern eine ganze Problemkategorie löst.
* Dekomposition: 
  * Wir teilen das Problem in verschiedene Teilprobleme. 
  * Wir überlegen uns, wie wir diese Teillösungen wieder zu einer Gesamtlösung zusammenbauen müssen.
* Mustererkennung: 
  * Wir halten nach Mustern im Bereich der verwendeten Daten oder auch in Bezug auf die Ablaufstruktur und damit nach Automatisierungspotential Ausschau. 
  * Immer wiederkehrende Lösungsteile lassen sich durch Programmiersprachen sehr effizient implementieren.

Auf Basis der Problemanalyse können dann **erste Lösungsansätze** entwickelt werden, die dann im Rahmen der Algorithmisierung (siehe unten) aufgegriffen und als Algorithmus umgesetzt werden.

#### Exkurs: Fundamentale Ideen der Softwareentwicklung
In der Informatikdidaktikk existiert das Konzept der **Fundamentalen Ideen**, die im Rahmen des Entwurfs von Softwaresystemen und auch für die weiter unten folgende Algorithmisierung zum Einsatz kommen können: 
 
> "Eine fundamentale Idee bezüglich eines Gegenstandsbereichs (Wissenschaft, Teilgebiet) ist ein Denk-, Handlungs-, Beschreibungs- oder Erklärungsschema, das
> 1. in verschiedenen Gebieten des Bereichs vielfältig anwendbar oder erkennbar ist (Horizontalkriterium)
> 2. auf jedem intellektuellen Niveau aufgezeigt und vermittelt werden kann (Vertikalkriterium)
> 3. zur Annäherung an eine gewisse idealisierte Zielvorstellung dient, die jedoch faktisch möglicherweise unerreichbar ist (Zielkriterium)
> 4. in der historischen Entwicklung des Bereichs deutlich wahrnehmbar ist und längerfristig relevant bleibt (Zeitkriterium)
> 5. einen Bezug zur Sprache und Denken des Alltags und der Lebenswelt besitzt (Sinnkriterium)" (Schwill, 1993)

Schwill identifiziert auf Basis dieses Kriteriensatzes folgende konkrete Ideen (hier in einer Modifikation nach Modrow für die Masteridee der Formalisierung), die für die Phase der Problemanalyse (siehe besonders Masteridee "Strukturierte Zerlegung") und auch für die Phase der Algorithmisierung (siehe besonders Masteridee der Algorithmisierung) zur Anwendung kommen können:

![](./Bilder/fundamentaleideen.png)
(Schwill/Schubert/Modrow)

### Algorithmisierung 
Im Rahmen der Algorithmisierung folgt die Beschreibung des Systems und eines dazu passenden Lösungsalgorithmus. Wir verwenden dazu (grafische) Methoden verschiedener Modellierungsparadigmen (darunter Datenmodellierung, Ablaufmodellierung, zustandsorientierte Modellierung, funktionale Modellierung, objektorientierte Modellierung), sowie dazu passende algorithmische Grundbausteine bzw. Datenstrukturen (siehe Thema "Zentrale Ideen" bzw. "Konzepte" weiter oben). 

> Ein Algorithmus ist eine eindeutige Handlungsvorschrift zur Lösung eines Problems oder einer Klasse von Problemen. Algorithmen bestehen aus endlich vielen, wohldefinierten Einzelschritten. Damit können sie zur Ausführung in ein Computerprogramm implementiert, aber auch in menschlicher Sprache formuliert werden. Bei der Problemlösung wird eine bestimmte Eingabe in eine bestimmte Ausgabe überführt. (https://de.wikipedia.org/wiki/Algorithmus)

Die Beschreibung des Algorithmus erfolgt z.B. über:

* Textuelle Beschreibung des Algorithmus (formlos, konzeptorientiert)
* [Pseudocode](https://de.wikipedia.org/wiki/Pseudocode)
* grafische Darstellungen zur Systembeschreibung, darunter:
  * [Flussdiagramme](https://en.wikipedia.org/wiki/Flowchart) bzw.[Programmablaufpläne] (https://de.wikipedia.org/wiki/Programmablaufplan)
  * [Struktogramme](https://www.inf-schule.de/) bzw. [Nassi-Shneidermann-Diagramm](https://de.wikipedia.org/wiki/Nassi-Shneiderman-Diagramm)
  * [Zustandsdiagramme](https://de.wikipedia.org/wiki/Zustandsdiagramm_(UML))
  * weitere [UML-Diagrammarten](https://de.wikipedia.org/wiki/Unified_Modeling_Language)

### Implementierung und Test

Nachdem wir den Lösungsalgorithmus entworfen haben, gehen wir in die Umsetzung über. Dazu suchen wir Werkzeuge (IDE, Programmiersprache, Compiler etc.), die es uns aufgrund der unterstützten Konzepte bzw. aufgrund des gewählten Modellierungsparadigmas ermöglichen, den Algorithmus als Computerprogramm umzusetzen, auszuführen und zu testen. 

Die Implementierung erfolgt iterativ in Zyklen. D.h. es werden Schritt für Schritt (weitere) Teile der Lösung implementiert und immer wieder getestet. 

Im Rahmen der Implementierung wird es aufgrund von Syntaxfehlern, Laufzeitfehlern oder auch logischen Fehlern im Ansatz zu Anpassungen des Lösungsansatzes, des Algorithmus und damit der Implementierung kommen. 

Die Lösung soll so weit wie möglich generalisiert werden, d.h. sie soll eine Klasse von Problemen und nicht nur ein spezifisches Problem mit bestimmten spezifischen Daten lösen.

## Methodische Prinzipien
siehe [Methodik](./Methodik.md)

## Anhang 2: Beispiele für Mini-Projekte für Anfänger

Für den einführenden Programmierunterricht eigenen sich Projekte zur Umsetzung im Unterricht wie die folgenden:

* Einfache Spiele wie Schere-Stein-Papier, Wörter raten (Hangman), Stadt Land Fluss, Zahlen raten
* Einfache Adventure-Games (Zork)
* Einfache Chatbots (Elisa)
* Einfache Textproduktionen wie Madlips, SVG-Grafiken zeichnen, Export-Funktionen
* Zahlen raten / KI für Zahlen raten (binäre Suche)
* Einfache Berechnungen mit Entscheidungen und Userinterface (z. B. BMI)
* Einfache Automaten (z. B. Ticketautomat, Tamagotchi, zelluläre Automaten für Game of Life)
* Einfache Microcontroller-Projekte (z.B. mit dem Micro:bit, siehe dazu das Schulbuch https://microbit.eeducation.at/wiki/Hauptseite)

Auf vielen Online-Programmierplattformen (wie etwa auf der Makecode-Plattform) oder auch in vielen Entwicklungsumgebungen sind außerdem oft auch Tutorials, Beispiele, kleine Projektaufgaben integriert.